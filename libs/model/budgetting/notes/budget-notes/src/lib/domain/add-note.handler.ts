import { HandlerTools } from '@iote/cqrs';
import { FunctionContext, FunctionHandler } from '@ngfi/functions';

import { Notes } from '@app/model/finance/notes';
import { Budget } from '@app/model/finance/planning/budgets';

import { AddNoteToBudgetCommand } from './add-note.command';

/**
 * Generic interface for command handlers.
 * 
 * This interface defines the contract that all command handlers must implement.
 * As per CQRS pattern, handlers are responsible for executing commands.
 * 
 * Note: While the base interface returns Promise<void>, this implementation
 * returns Promise<T> to provide rich feedback about the operation result,
 * which is a common pattern in production systems for better error handling
 * and user feedback.
 * 
 * @template TCommand - The command type this handler processes
 */
export interface ICommandHandler<TCommand> 
{
  /**
   * Execute the given command
   * @param command - The command to execute
   * @returns Promise that resolves when command execution is complete
   */
  execute(command: TCommand): Promise<void>;
}

/**
 * Result interface for the AddNoteToBudget operation
 */
export interface AddNoteToBudgetResult 
{
  success: boolean;
  noteId?: string;
  message?: string;
}

/**
 * Handler for adding notes to budgets.
 * 
 * This handler implements the CQRS pattern by processing AddNoteToBudgetCommand
 * and performing the necessary business logic and data persistence operations.
 * 
 * Responsibilities:
 * - Validate command input
 * - Verify budget existence
 * - Create and persist the note
 * - Return operation result
 */
export class AddNoteToBudgetHandler extends FunctionHandler<AddNoteToBudgetCommand, AddNoteToBudgetResult>
{
  /**
   * Execute the command to add a note to a budget
   * 
   * @param command - The command containing note and budget information
   * @param context - The function execution context
   * @param tools - Handler tools providing logging and repository access
   * @returns Promise resolving to the operation result
   */
  public async execute(
    command: AddNoteToBudgetCommand, 
    context: FunctionContext, 
    tools: HandlerTools
  ): Promise<AddNoteToBudgetResult> 
  {
    tools.Logger.log(() => `[AddNoteToBudgetHandler].execute: Adding note to budget ${command.budgetId}`);

    try {
      // Validation: Check if note content is provided and not empty
      if (!command.note || command.note.trim().length === 0) {
        tools.Logger.error(() => `[AddNoteToBudgetHandler].execute: Note content is empty`);
        return {
          success: false,
          message: 'Note content cannot be empty'
        };
      }

      // Validation: Check if budgetId is provided
      if (!command.budgetId || command.budgetId.trim().length === 0) {
        tools.Logger.error(() => `[AddNoteToBudgetHandler].execute: Budget ID is missing`);
        return {
          success: false,
          message: 'Budget ID is required'
        };
      }

      // Validation: Check if orgId is provided
      if (!command.orgId || command.orgId.trim().length === 0) {
        tools.Logger.error(() => `[AddNoteToBudgetHandler].execute: Organization ID is missing`);
        return {
          success: false,
          message: 'Organization ID is required'
        };
      }

      // Get budget repository and verify budget exists
      const budgetRepo = tools.getRepository<Budget>(`orgs/${command.orgId}/budgets`);
      const budget = await budgetRepo.getDocumentById(command.budgetId);

      if (!budget) {
        tools.Logger.error(() => `[AddNoteToBudgetHandler].execute: Budget ${command.budgetId} not found`);
        return {
          success: false,
          message: `Budget with ID ${command.budgetId} does not exist`
        };
      }

      // Create the note object
      const noteData: Notes = {
        note: command.note.trim(),
        id: '', // Will be generated by the repository
      };

      // Get notes repository and persist the note
      const notesRepo = tools.getRepository<Notes>(`orgs/${command.orgId}/budgets/${command.budgetId}/notes`);
      const noteId = `note-${Date.now()}-${command.userId}`;
      
      await notesRepo.write(noteData, noteId);

      tools.Logger.log(() => `[AddNoteToBudgetHandler].execute: Successfully added note ${noteId} to budget ${command.budgetId}`);

      return {
        success: true,
        noteId: noteId,
        message: 'Note added successfully'
      };

    } catch (error) {
      tools.Logger.error(() => `[AddNoteToBudgetHandler].execute: Error adding note - ${error}`);
      return {
        success: false,
        message: `Failed to add note: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
}
